############
#Bayesian Quadrature with Gaussian Process
############
library(mvtnorm)

computeGPBQ <- function(dim, epochs, N=10, FUN) 
  # method for computation of the integration
  # includes query sequential design
  # input:
  #     dim:
  #     epochs: number of training instances
  #     N:
{
  #define genz function
  genz <- cont
  meanValueGP <- c()
  standardDeviationGP <- c()
  
  X <- randomLHS(N, dim)
  Y <- genz(X)
  
  K <- matrix(0,nrow=N,ncol=N)
  
  z <- rep(0, N)
  
  # compute kernel matrix for starting dataset
  compute_kernel_z(z, K, X, dim, N)


  
  meanValueGP[1] <- t(z) %*% chol2inv(K) %*% Y
  
  standardDeviationGP[1] <- t(z)%*%chol2inv(K)%*%z #not quite right, missed out first term
  
  
  # train
  for (p in 1:epochs) {
    print(c("GP: Epochs no.:", p))
    
    candidateSet <- randomLHS(100,dim)
    
    candidate_Var <- rep(0, 100)
    
    candidate_p <- rep(0, 100)
    
    z <- c(z, 0)
    
    K_prime <- diag(N+p)
    
    K_prime[1:(N+p-1), 1:(N+p-1)] <- K
    
    calculate_candidate(candidate_p, candidate_Var, z, candidateSet, K_prime, X, dim, N, p)
    
    index <- which(candidate_Var == max(candidate_Var))[1]
    
    K_prime[N+p,1:(N+p-1)] <- gaussianKernel(candidateSet[index,], X)
    
    K_prime[1:(N+p-1),N+p] <- gaussianKernel(candidateSet[index,], X)
    
    X <- rbind(X,candidateSet[index,])
    
    additionalResponse <- as.matrix( t(candidateSet[index,]), ncol = length(candidateSet[index,]) )
    
    Y <- c(Y, genz(additionalResponse))
    
    K <- K_prime
    
    # add in extra term obtained by integration
    z[N+p] <- pmvnorm(rep(0,dim), rep(1,dim), mean = X[N+p,], sigma = diag(dim))[[1]] * (2*pi)^(dim/2)
    
    meanValueGP[p+1] <- t(z) %*% chol2inv(K) %*% as.matrix(Y)
    
    standardDeviationGP[p+1] <- t(z)%*%chol2inv(K)%*%z #not quite right, missed out first term
    
  }
  
  return (list("meanValueGP" = meanValueGP, "standardDeviationGP" = standardDeviationGP))
}
